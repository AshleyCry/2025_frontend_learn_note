# 简历相关知识点

### IoC（控制反转）与DI（依赖注入）

#### IoC

- IoC是一种设计原则，讲传统流程控制权从应用程序代码转移到框架或者容器中，组件不再显式地创建它需要的依赖，而是将这一过程“交给外部”来完成。简单说就是，“不要调用我们，我们会调用你”。

- 传统流程控制实例：

- ```js
  // 传统方式 - 应用程序控制流程
  class User {
    constructor() {
      this.db = new MySQLDatabase(); // 直接创建依赖
    }
  
    save(data) {
      this.db.save(data);
    }
  }
  
  const user = new User();
  user.save({ name: 'John' });
  ```

- IoC实现实例

- ```js
  // IoC方式 - 控制权反转给调用者
  class User {
    constructor(database) { // 依赖通过参数传入
      this.db = database;
    }
  
    save(data) {
      this.db.save(data);
    }
  }
  
  // 现在调用者决定使用什么数据库
  const mysqlDb = new MySQLDatabase();
  const user = new User(mysqlDb);
  user.save({ name: 'John' });
  ```

#### DI

- DI（依赖注入）是实现控制反转的一种方式，表示将组件需要的依赖通过某种方式（构造函数，方法参数，或者属性）注入到组件中，而不是让组件自己主动的去创建依赖

- 构造函数注入

  ```js
  class UserService {
    constructor(userRepository) {
      this.userRepository = userRepository;
    }
  
    getUser(id) {
      return this.userRepository.get(id);
    }
  }
  
  const userRepository = new UserRepository();
  const userService = new UserService(userRepository);
  ```

- 属性注入

  ```js
  class UserService {
    setRepository(userRepository) {
      this.userRepository = userRepository;
    }
  
    getUser(id) {
      return this.userRepository.get(id);
    }
  }
  
  const userService = new UserService();
  userService.setRepository(new UserRepository());
  ```

- 方法注入

  ```js
  class UserService {
    getUser(userRepository, id) {
      return userRepository.get(id);
    }
  }
  
  const userService = new UserService();
  const user = userService.getUser(new UserRepository(), 123);
  ```

- 完整示例

  ```js
  // 定义接口/抽象
  class Database {
    save(data) {
      throw new Error('Method not implemented');
    }
  }
  
  // 具体实现
  class MySQLDatabase extends Database {
    save(data) {
      console.log(`Saving ${JSON.stringify(data)} to MySQL`);
    }
  }
  
  class MongoDB extends Database {
    save(data) {
      console.log(`Saving ${JSON.stringify(data)} to MongoDB`);
    }
  }
  
  // 业务类，依赖抽象而非具体实现
  class UserService {
    constructor(database) {
      if (!(database instanceof Database)) {
        throw new Error('Invalid database dependency');
      }
      this.database = database;
    }
  
    createUser(userData) {
      // 业务逻辑...
      this.database.save(userData);
    }
  }
  
  // 组合根 - 在这里组装所有依赖
  function configureApp() {
    // 可以轻松切换数据库实现
    const database = process.env.NODE_ENV === 'production' 
      ? new MongoDB() 
      : new MySQLDatabase();
    
    return new UserService(database);
  }
  
  // 使用应用
  const userService = configureApp();
  userService.createUser({ name: 'Alice', age: 30 });
  ```

  

#### windows上outlook的兼容性

- windows版office2019自带的outlook并没有一个自己的HTML渲染引擎，而是使用word的渲染引擎去解析HTML。它不支持html5，不支持css3
- 例如display, position, max-width, max-height等不兼容
- 不能使用任何css3的新特性，比如flex, grid
- 和布局有关的组件，只能使用table来进行布局
- 只能使用行内样式
- 尽量只使用table / tr / td / span / img / a / div这几个标签
- 只有div的margin会偶尔被正确的识别，其他标签都有可能让padding和margin消失
- 如果一个div内部含有table，它的margin会让table背景色和边框混乱
- 无法使用line-height
- 小心使用div，outlook有时候会把他转换为p，具体逻辑还不明确
- 图片唯一能够控制大小的方法就是使用img标签上的width属性和height属性

![image-20250510192643708](.\assets\image-20250510192643708.png)

- Client发送给Server的数据包分类：

  - {hi}：Client和Server建立长链后，Client发送{hi}数据包，告诉server当前client的版本、设备类型、语言等信息；

  - {login}：用户登录和Session安全验证；

  - {sub}：创建或订阅topic，或将session附加到订阅的topic上或者拉取或更新topic数据；

  - {leave}：取消订阅，或者session附加topic的关系取消；

  - {pub}：发送数据消息给指定topic的订阅者，订阅者接收到server发送的{data}数据包；

  - {get}：获取topic的metadata信息，例如topic的描述信息，此topic的订阅者列表，或者拉取历史消息；

  - {set}：更新topic的metadata信息，删除消息或删除topic；

  - {del}：用于删除操作，包括删除消息，删除订阅关系，删除topic和用户；

  - {note}：client发送通知给topic的订阅者，例如消息已收到，消息已读，当前正在输入等；

- Server发送给Client的数据包分类：

  - {data}：server收到client发送的{pub}数据包后，会入库且为此条数据分配一个seq，并以{data}数据包发送订阅此topic的所有user；seq对每一个topic唯一且连续递增；

  - {ctr}：server收到client发送的数据包，发送{ctr}反馈，包含code，消息id等

  - {meta}：关于topic的metadata数据或者订阅者列表，对应client发送{get}、{set}、{sub}数据包的反馈

  - {info}：server收到client发送的{note}数据包，会{info}包转发给对应的topic订阅者，此类型消息也不会入库；

- topic:

  - Topic的订阅关系，并且缓存了User订阅的Topic表，当要想某个用户发送消息时，会取出该用户的Topic,通过Topic进行publish；

  - Topic发送消息时，会交给SDK进行发送，SDK会对发送的内容封装成对应的数据包，然后交给Connection发送；每个Topic都维护订阅关系表，即当前Topic被哪些user订阅，并一userId为Key，Subscription为Value的Map中；Subscription中维护这当前user订阅的Topic以及seq和已读数，并且Topic类提供了相应的回调。

  - Topic发送消息时，会交给SDK进行发送，SDK会对发送的内容封装成对应的数据包，然后交给Connection发送；Topic提供一系列的方法，例如subscribe，publish，action等，并且在subscribe前，检查本地是否保存有此topic订阅关系，如果没有，则保存并添加Topic列表的缓存中；