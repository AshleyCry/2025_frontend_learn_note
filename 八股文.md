#### 箭头函数与普通函数的区别

1. this绑定

   - 普通函数：
     - this值由调用方式决定（动态绑定）
     - 可以是：调用对象、new实例、window/global、绑定对象等
   - 箭头函数
     - this继承自外层函数作用域（词法绑定）
     - 无法通过call/apply/bind改变this指向

   ```js
   const obj = {
     name: 'Alice',
     regularFunc: function() {
       console.log(this.name);
     },
     arrowFunc: () => {
       console.log(this.name); // this指向window/global
     }
   };
   
   obj.regularFunc(); // 'Alice'
   obj.arrowFunc();   // undefined (或在浏览器中可能是空字符串)
   ```

​		

```js
var id = 'Global'

function fun1() {
    // setTimeout中使用普通函数
    setTimeout(function fun3() {
    	console.log(this.id)
    }, 2000)
}

function fun2() {
    // setTimeout中使用箭头函数
    setTimeout(() => {
    	console.log(this.id)
    }, 2000)
}
fun1() // 'Global'
fun2() // 'Global'
fun1.call({ id: 'Obj' }) // 'Global'
fun2.call({ id: 'Obj' }) // 'Obj'

1. fun3 本身有 this，因为setTimout 使得 fun3 是在全局上下文中执行，这个 this 指向全局执行环境

2. 同理，setTimout 使得箭头函数是在全局上下文中执行，但是箭头函数本身没有 this，它会沿着作用域链查找，找到fun2中创建的this，也指向全局执行环境
3. fun1.call 调用过程中，修改了 fun1 的 this 指向，但fun3 本身也创建有 this，setTimeout使得这个 this 指向全局执行环境
4. fun1.call 调用过程中，修改了 fun1 的 this 指向，箭头函数没有 this，按照作用域链找到 fun1 的 this，于是最后指向`{id: 'Obj'}`
```

2. 构造函数能力

   - 普通函数

     - 可以用作构造函数，用new调用
     - 会创建实例对象

   - 箭头函数

     - 不能用作构造函数
     - 用new调用会报错

     ```js
     function RegularFunc() {}
     const ArrowFunc = () => {};
     
     const rf = new RegularFunc(); // 正常
     const af = new ArrowFunc();   // TypeError: ArrowFunc is not a constructor
     
     ```

3. arguments对象

   - 普通函数
     - 有自己的arguments对象
     - 包含所有传入的参数
   - 箭头函数
     - 没有自己的arguments对象
     - 可以访问外层函数的arguments

   ```js
   function regular(a, b) {
     console.log(arguments); // Arguments(2) [1, 2]
   }
   
   const arrow = (a, b) => {
     console.log(arguments); // ReferenceError: arguments is not defined
   };
   
   regular(1, 2);
   arrow(1, 2);
   ```

4. prototype

   - 普通函数
     - 由prototype属性
     - 用于构造函数和继承
   - 箭头函数
     - 没有prototype属性
     - 因此不能用做构造函数

   ```js
   function Regular() {}
   console.log(Regular.prototype); // {constructor: ƒ}
   
   const Arrow = () => {};
   console.log(Arrow.prototype);   // undefined
   ```

5. yield关键字

   - 普通函数
     - 可以用作生成器函数(function*)
   - 箭头函数
     - 不能用作生成器函数
     - 不能包含yield表达式

   ```js
   function* regularGen() { yield 1; } // 正常
   const arrowGen = *() => { yield 1; }; // SyntaxError
   ```

6. 总结

   | 特性           | 普通函数 | 箭头函数           |
   | :------------- | :------- | :----------------- |
   | this绑定       | 动态绑定 | 词法绑定           |
   | 构造函数       | 可以     | 不可以             |
   | arguments对象  | 有       | 无                 |
   | prototype属性  | 有       | 无                 |
   | yield关键字    | 可用     | 不可用             |
   | 语法简洁性     | 相对冗长 | 更简洁             |
   | 方法定义       | 适合     | 不适合             |
   | 命名函数表达式 | 支持     | 不支持（总是匿名） |

#### 同源策略

1. 源(origin)

   - 源由三部分组成
   - 协议(Protocol): 如http, https
   - 域名(Hostname)：如www.baidu.com
   - 端口(port)：80, 443

2. 同源判定规则

   如果两个URL协议、域名、端口完全相同，则属于同源

   | URL1                         | URL2                         | 是否同源 | 原因       |
   | :--------------------------- | :--------------------------- | :------- | :--------- |
   | `https://example.com/a.html` | `https://example.com/b.html` | 是       | 完全相同   |
   | `https://example.com`        | `https://example.com:8080`   | 否       | 端口不同   |
   | `http://example.com`         | `https://example.com`        | 否       | 协议不同   |
   | `https://sub.example.com`    | `https://example.com`        | 否       | 子域名不同 |

#### 同源策略的限制范围

1. DOM访问限制

   禁止不同源的JavaScript操作iframe内的DOM

   ```js
   // 假设当前页面是 https://a.com
   const iframe = document.getElementById('myIframe'); // iframe加载了 https://b.com
   iframe.contentWindow.document // 报错：无法访问
   ```

2. 网络请求限制

   禁止通过XMLHttpRequest或者Fetch发起跨域请求

   ```js
   fetch('https://other-domain.com/api')
     .then(response => response.json())
     .catch(error => console.error('被同源策略阻止', error));
   ```

3. 存储访问限制

   禁止访问不同源的Cookie，LocalStorage，IndexedDB等

#### 为什么需要同源策略

没有同源策略的后果：

- 恶意网站可以读取其他网站的DOM（如银行网站）
- 窃取用户Cookie和敏感数据
- 发起CSRF（跨站请求伪造）攻击

#### 特殊例外情况

某些标签允许加载跨域资源（通常限制交互）

- `<img src="跨域图片">`
- `<link rel="stylesheet" href="跨域CSS">`
- `<script src="跨域JS">`（但无法读取错误详情）

#### 跨域解决方案

##### CORS（跨域资源共享）

1. 基本概念

   CORS是W3C标准，也是最主流的跨域解决方案，通过HTTP头实现

   跨源资源共享标准新增了一组 [HTTP 标头](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Headers)字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Methods/GET) 以外的 HTTP 请求，或者搭配某些 [MIME 类型](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/MIME_types)的 [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Methods/POST) 请求），浏览器必须首先使用 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Reference/Methods/OPTIONS) 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（例如 [Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Cookies) 和 [HTTP 认证](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Guides/Authentication)相关数据）。

2. 工作流程

   - 简单请求(Simple Request)
     - 条件：GET、HEAD、POST方法，Content-Type为text/plain、multipart/form-data或application/x-www-form-urlencoded
     - 浏览器直接发送请求，带`Origin`头
     - 服务器响应`Access-Control-Allow_Origin`
   - 预检请求(Preflight Request)
     - 非简单请求前，浏览器先发OPTIONS请求
     - 服务器确认允许后，才发送真实请求

3. 服务端配置

   ```http
   // 允许特定源
   Access-Control-Allow-Origin: https://yourdomain.com
   // 允许携带凭证（如cookies）
   Access-Control-Allow-Credentials: true
   // 允许的请求方法
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE
   // 允许的请求头
   Access-Control-Allow-Headers: Content-Type, Authorization
   // 预检请求缓存时间
   Access-Control-Max-Age: 86400
   ```

4. 前端实现

   ```js
   // 带凭证的请求
   fetch('https://api.other.com', {
     credentials: 'include'
   });
   
   // 自定义头会触发预检
   fetch('https://api.other.com', {
     method: 'POST',
     headers: {
       'Content-Type': 'application/json',
       'X-Custom-Header': 'value'
     }
   });
   ```

##### JSONP

1. 实现原理

   利用`<script>`标签不受同源策略限制的特性，事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的`script`标签发起一个请求（将回调函数的名称放到这个请求的`query`参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，前端的`script`标签请求到这个执行的回调函数后会立马执行，于是就拿到了执行的响应数据。

2. 优点

   1. 兼容性好，古老的浏览器中可以运行，不需要XMLHttpRequest或ActiveX的支持
   2. 请求完毕后可以通过调用callback的方式返回结果

3. 缺点

   1. 只支持GET请求
   2. 只支持跨域HTTP请求，不能解决不同域两个页面之间如何进行JS调用的问题

4. 应用流程

   1. 设定一个`script`标签

   ```js
   <script src="http://jsonp.js?callback=cb"></script>
   
   // 或
   
   let script = document.createElement('script');
   script.src = "http://jsonp.js?callback=cb";
   body.append(script)
   ```

   2. `callback`定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将`function(response)`传递回客户端

      ```js
      router.get('/', function (req, res, next) {
          (() => {
              const data = {
                  x: 10
              };
              let params = req.query;
              if (params.callback) {
                  let callback = params.callback;
                  console.log(params.callback);
                  res.send(`${callback}(${JSON.stringify(data.x)})`);
              } else {
                  res.send('err');
              }
          })();
      });
      ```

   3. 客户端接收到返回的JS脚本，开始解析和执行`function(response)`

5. JSONP实现

   拼接URL，然后将动态添加一个`script`到头部

   **前端JSONP方法：**

   ```js
   function jsonp(req) {
       var script = document.createElement('script');
       var url = req.url + '?callback=' + req.callback.name;
       script.src = url;
       document.getElementsByTagName('head')[0].appendChild(script);
   }
   ```

   **前端JS示例**

   ```js
   function hello(res){
       alert('hello ' + res.data);
   }
   jsonp({
       url : '',
       callback : hello 
   });
   ```

   **服务端代码：**

   ```js
   var http = require('http');
   var urllib = require('url');
   
   var port = 8080;
   var data = {'data':'world'};
   
   http.createServer(function(req,res){
       var params = urllib.parse(req.url,true);
       if(params.query.callback){
           console.log(params.query.callback);
           // jsonp
           var str = params.query.callback + '(' + JSON.stringify(data) + ')';
           res.end(str);
       } else {
           res.end();
       }
       
   }).listen(port,function(){
       console.log('jsonp server is on');
   });
   ```

6. JSONP安全问题

   1. CSRF攻击

      前端构造一个恶意页面，请求JSONP接口，收集服务端的敏感信息。如果JSONP接口还涉及一些敏感操作或信息（比如登录、删除等操作），那就更不安全了。

      **解决方法**：验证JSONP的调用来源（`Referer`），服务端判断 `Referer` 是否是白名单，或者部署随机 `Token` 来防御。

   2. XSS漏洞

      不严谨的 `content-type` 导致的 `XSS` 漏洞，想象一下 JSONP 就是你请求 `http://abc.com?callback=douniwan`, 然后返回 `douniwan({ data })`，那假如请求 `http://abc.com?callback=<script>alert(1)</script>` 不就返回 `<script>alert(1)</script>({ data })`了吗，如果没有严格定义好 `Content-Type（ Content-Type: application/json ）`，再加上没有过滤 `callback` 参数，直接当 HTML 解析了，就是一个赤裸裸的 `XSS` 了。

      **解决方法**：严格定义 `Content-Type: application/json`，然后严格过滤 `callback` 后的参数并且限制长度（进行字符转义，例如`<`换成`&lt`，`>`换成`&gt`）等，这样返回的脚本内容会变成文本格式，脚本将不会执行。

   3. 服务器被黑，返回一串恶意执行代码

      可以将执行的代码转发到服务端进行校验 JSONP 内容校验，再返回校验结果

##### 代理服务器方案

1. 开发环境的代理（webpack/vite）

   ```js
   // vite.config.js
   export default {
     server: {
       proxy: {
         '/api': {
           target: 'http://other-server.com',
           changeOrigin: true,
           rewrite: path => path.replace(/^\/api/, '')
         }
       }
     }
   }
   ```

2. Nginx反向代理设置

   ```nginx
   server {
       listen 80;
       server_name yourdomain.com;
   
       location /api/ {
           proxy_pass http://api.other.com/;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
       }
   }
   ```

3. 优点

   - 完全绕过浏览器限制
   - 可集中处理鉴权、日志等

##### WebSocket跨域

1. 实现方式

   WebSocket不受同源策略限制

   ```js
   const socket = new WebSocket('wss://other-domain.com');
   
   socket.onmessage = function(event) {
     console.log('收到消息:', event.data);
   };
   ```

2. 服务端配置

   ```http
   Sec-WebSocket-Protocol: chat
   ```

##### postMessage跨文档通信

1. 窗口间通信

   ```js
   // 发送方
   otherWindow.postMessage({ key: 'value' }, 'https://target.com');
   
   // 接收方
   window.addEventListener('message', (event) => {
     if (event.origin !== 'https://trusted.com') return;
     console.log('收到消息:', event.data);
   });
   ```

2. 适用场景

   - 不同窗口/iframe间通信
   - 微前端架构中子应用通信

##### 降域

降域是通过将不同域的 `document.domain` 指定为其共同父域从而使其同源的跨域解决方案。
`blog.sch.com`、`game.sch.com` 具有共同的父域 `sch.com`。
那么将两个域名下的页面的域修改为 `sch.com` 即可解决跨域问题。

```js
document.domain = 'sch.com'
```

- `document.domain` 指定的域必须为当前域或者其父域。
- 子域与父域跨域时，父域也必须指定 `document.domain`。



#### Attribute与Property

1. Attribute（属性）

   - 定义

     - 它是HTML标签上的显式属性，直接写在HTML代码中（如`<input id="myInput" value="Hello">`中的`id`和`value`）,通常用于初始化元素的属性（properties），或者存储自定义数据（`data-*`）
     - 始终是字符串类型

   - 访问方式

     - 通过DOM元素的`getAttribute()`和`setAttribute()`方法操作

       ```js
       const input = document.querySelector('input');
       input.getAttribute('value'); // 返回字符串 "hello"
       input.setAttribute('value', 'new value');
       ```

   - 特点

     - 初始时会影响元素的默认行为（如`value`的初始值）
     - 修改后不会自动同步到对应的Property（某些特殊属性除外，如`id`）
     - 不是所有的attributes都有对应的properties。例如，`data-*` attributes就没有对应的properties。相反，有些properties（如`textContent`）也没有对应的attributes。

2. Property（特性）

   - 定义

     - 是DOM对象（JavaScript对象）上的属性，通过JavaScript访问
     - 值可以是任意JavaScript类型（布尔值，数字，对象等）

   - 访问方式

     - 直接通过DOM对象的属性访问或修改

       ```
       const input = document.querySelector('input');
       input.value; // 返回当前值（可能是动态变化的）
       input.value = 'new value'; // 直接修改
       ```

   - 特点

     - 反应元素的当前状态（例如`input.value`会随用户输入而改变）

       ```html
       <input id="myInput" value="hello">
       ```

       ```js
       const input = document.getElementById('myInput');
       
       // 初始时 Attribute 和 Property 一致
       input.getAttribute('value'); // "hello" (字符串)
       input.value;                // "hello" (字符串)
       
       // 用户修改输入框内容为 "world" 后
       input.getAttribute('value'); // 仍是 "hello"（Attribute 不变）
       input.value;                // "world" （Property 反映当前值）
       ```

       ```html
       <button disabled="disabled">Click</button>
       ```

       ```js
       const button = document.querySelector('button');
       
       // Attribute 是字符串
       button.getAttribute('disabled'); // "disabled" (字符串)
       
       // Property 是布尔值
       button.disabled; // true (布尔值)
       ```

     - 修改后通常不会同步到Attribute（例外：`href`, `id`等标准属性）

       ```js
       // <a id="link" href="/page"></a>
       const link = document.querySelector('a');
       
       link.href = '/new-page';
       link.getAttribute('href'); // 同步变为 "/new-page"
       ```

### JS严格模式的限制

#### 语法限制

1. 意外创建全局变量：禁止未声明变量的赋值

   ```js
   "use strict";
   x = 10; // ReferenceError
   ```

2. 删除不可删除的属性：禁止删除变量、函数或不可删除属性

   ```js
   delete Object.prototype; // TypeError
   ```

3. 重复参数名：函数参数不能重名

   ```js
   function foo(a, a) {} // SyntaxError
   ```

4. 八进制字面量：禁止使用八进制数字字面量（0开头）

   ```js
   var n = 0100; // SyntaxError
   ```

5. with语句：禁止使用with语句

   ```js
   with (obj) {} // SyntaxError
   ```

#### 语义变化

1. this绑定：全局函数中的`this`为`undefined`（非严格模式下指向window）

   ```js
   function f() { return this; }
   f() === undefined; // true
   ```

2. arguments限制

   1. arguments不再与形参绑定

      非严格模式（参数与arguments联动）：

      ```js
      function update(a) {
        a = 10;
        console.log(arguments[0]); // 10
        arguments[0] = 20;
        console.log(a); // 20
      }
      update(1);
      ```

      严格模式（参数与arguments独立）

      ```js
      "use strict";
      function update(a) {
        a = 10;
        console.log(arguments[0]); // 1 （保持原始值）
        arguments[0] = 20;
        console.log(a); // 10 （不受影响）
      }
      update(1);
      ```

      

   2. arguments.callee（引用当前正在执行的函数本身）和arguments.caller（获取调用当前函数的函数）被禁用

      非严格模式

      ```js
      var factorial = function(n) {
        return n <= 1 ? 1 : n * arguments.callee(n-1);
      };
      ```

      严格模式

      ```js
      "use strict";
      var factorial = function(n) {
        // arguments.callee 不可用
        return n <= 1 ? 1 : n * factorial(n-1); // 必须使用函数名
      };
      ```

      

3. eval的限制

   非严格模式

   ```js
   eval("var x = 10;");
   console.log(x); // 10 （变量泄漏到外部作用域）
   ```

   严格模式

   ```js
   "use strict";
   eval("var x = 10;");
   console.log(x); // ReferenceError: x is not defined
   ```

4. 对不可写属性赋值

   非严格模式（静默失败）

   ```js
   var obj = {};
   Object.defineProperty(obj, 'readOnly', { value: 42, writable: false });
   obj.readOnly = 100; // 无效果但不报错
   console.log(obj.readOnly); // 42
   ```

   严格模式（抛出异常）

   ```js
   "use strict";
   var obj = {};
   Object.defineProperty(obj, 'readOnly', { value: 42, writable: false });
   obj.readOnly = 100; // TypeError: Cannot assign to read only property
   ```

5. 删除不可删除的属性

   非严格模式（静默失败）

   ```js
   delete Object.prototype; // 返回false但不报错
   ```

   严格模式（抛出错误）

   ```js
   "use strict";
   delete Object.prototype; // TypeError: Cannot delete property 'prototype' of function Object()
   ```

6. 对eval和arguments的操作限制

   严格模式下禁止的操作：

   ```js
   "use strict";
   var eval = 10; // SyntaxError
   var arguments = 20; // SyntaxError
   ```

   这些语义变化使得JavaScript更加规范和安全，减少了可能引发问题的隐式行为



### weakRef与weakMap

#### weakRef（弱引用）

ES2021引入的特性，允许创建对对象的弱引用，不会阻止垃圾回收器回收该对象

**基本用法**

```js
let obj = { data: "important info" };
const weakRef = new WeakRef(obj);

// 获取引用的对象
const deref = weakRef.deref();
if (deref) {
  console.log(deref.data); // "important info"
}

// 当obj不再有其他强引用时
obj = null;

// 下次垃圾回收后
setTimeout(() => {
  console.log(weakRef.deref()); // undefined
}, 1000);
```

**使用场景**

1. 缓存系统：当对象不再被使用时自动释放
2. DOM元素跟踪：不阻止DOM元素被回收
3. 大型对象监控：知道对象何时被回收

#### weakMap（弱映射）

ES6引入的集合类型，键必须是对象，且对键是弱引用的

**基本用法**

```js
const weakMap = new WeakMap();

let keyObj = { id: 1 };
weakMap.set(keyObj, "secret data");

console.log(weakMap.get(keyObj)); // "secret data"

// 当keyObj不再有其他引用时
keyObj = null;

// 键值对会被自动移除（下次垃圾回收时）
```

**与普通 Map 的区别**

| 特性       | WeakMap                | Map        |
| :--------- | :--------------------- | :--------- |
| 键类型     | 只能是对象             | 任意值     |
| 键引用类型 | 弱引用                 | 强引用     |
| 可迭代     | 否                     | 是         |
| 大小查询   | 无size属性             | 有size属性 |
| 自动清理   | 键被回收时自动移除条目 | 需手动删除 |

**使用场景**

1. 私有成员存储

   ```js
   const privateData = new WeakMap();
   
   class Person {
     constructor(name) {
       privateData.set(this, { name });
     }
     
     getName() {
       return privateData.get(this).name;
     }
   }
   ```

2. DOM元素元数据存储

   ```js
   const domMetadata = new WeakMap();
   
   function setMetadata(domElement, metadata) {
     domMetadata.set(domElement, metadata);
   }
   
   function getMetadata(domElement) {
     return domMetadata.get(domElement);
   }
   ```

3. 缓存实现

   ```js
   const cache = new WeakMap();
   
   function compute(obj) {
     if (!cache.has(obj)) {
       const result = /* 复杂计算 */;
       cache.set(obj, result);
     }
     return cache.get(obj);
   }
   ```

#### 注意事项

1. **不可枚举**：WeakMap 和 WeakRef 都不能枚举其内容
2. **依赖垃圾回收**：清理时机取决于垃圾回收器
3. **谨慎使用**：WeakRef 可能使代码更难预测
4. **兼容性**：较新的JavaScript环境支持
   - WeakMap: ES6+ (广泛支持)
   - WeakRef: ES2021+ (较新环境)

### 内存泄露

- 定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。
- js中可能出现的内存泄漏情况：结果：变慢，崩溃，延迟大等
- js中可能出现的内存泄漏原因1、全局变量2、dom 清空时，还存在引用3、定时器未清除4、子元素存在引起的内存泄露

### script引入方式

#### 1. 内联脚本

直接在HTML文件中使用<script>标签嵌入JS代码：

```html
<script>
  console.log("这是内联脚本");
  function hello() {
    alert("Hello World!");
  }
</script>
```

特点：

- 代码直接嵌入HTML
- 适合小型脚本或快速测试
- 不利于代码维护合缓存

#### 2. 外部脚本（External Script）

通过`src`属性引入外部JavaScript文件：

```html
<script src="path/to/script.js"></script>
```

特点：

- 实现HTML和JavaScript的分离
- 有利于代码维护和复用
- 可以被浏览器缓存
- 推荐用于生产环境

#### 3. 模块化引入（ES Modules）

使用ES6模块系统引入JavaScript：

```html
<script type="module" src="path/to/module.js"></script>
```

或在模块中导入其他模块：

```js
// module.js
import { function1 } from './other-module.js';
```

特点：

- 支持现代模块化开发
- 自动启用严格模式
- 支持静态分析和树摇优化
- 有自己独立的作用域

#### 4. 动态加载（Dynamic Import）

使用JavaScript动态加载脚本

```js
// 使用 import() 函数动态加载模块
import('./module.js')
  .then(module => {
    module.doSomething();
  })
  .catch(err => {
    console.error("加载失败", err);
  });

// 或传统方式动态创建 script 标签
const script = document.createElement('script');
script.src = 'path/to/script.js';
document.body.appendChild(script);
```

特点：

- 按需加载，提高初始加载性能
- 适合大型应用的代码分割
- 可以控制加载时机

#### 5. defer和async属性

控制脚本加载和执行时机：

```html
<!-- 异步加载，下载完成后立即执行 -->
<script async src="script.js"></script>

<!-- 延迟执行，等文档解析完成后执行 -->
<script defer src="script.js"></script>
```

| 属性    | 加载时机 | 执行时机                            | 顺序保证 |
| :------ | :------- | :---------------------------------- | :------- |
| 无      | 立即加载 | 立即执行，阻塞HTML解析              | 是       |
| `async` | 异步加载 | 加载完成后立即执行                  | 否       |
| `defer` | 异步加载 | 文档解析完成后，DOMContentLoaded 前 | 是       |

#### 6. 传统兼容内容（Legacy）

为不支持JavaScript的浏览器提供备用内容

```html
<script>
  // 现代JavaScript代码
</script>
<noscript>
  <p>您的浏览器不支持JavaScript或已禁用</p>
</noscript>
```

#### 最佳实践建议

1. **生产环境**优先使用外部脚本
2. **性能关键**页面使用 `defer` 或 `async`
3. **现代应用**使用 ES Modules
4. **大型应用**考虑动态导入实现代码分割
5. 避免在文档中间使用阻塞式脚本（无 `async`/`defer`）
6. 模块脚本默认使用严格模式，无需声明 `"use strict"`

#### 示例：现代Web应用的典型引入方式

```html
<!DOCTYPE html>
<html>
<head>
  <!-- 关键CSS -->
  <link rel="stylesheet" href="styles.css">
  
  <!-- 非关键JS，延迟加载 -->
  <script defer src="analytics.js"></script>
  
  <!-- 预加载重要资源 -->
  <link rel="preload" href="main.js" as="script">
</head>
<body>
  <!-- 页面内容 -->
  
  <!-- 主JS文件 -->
  <script type="module" src="main.js"></script>
  
  <!-- 不支持模块的备用方案 -->
  <script nomodule src="legacy-bundle.js"></script>
</body>
</html>
```

选择哪种引入方式取决于项目需求、目标浏览器支持范围和性能考虑。现代Web开发推荐使用ES Modules结合动态导入的方式。

### 回流与重绘

#### 回流（Reflow，Layout）

当渲染树（Render Tree）中的一部分或全部因为元素的**尺寸、布局、隐藏等几何属性**改变而需要重新构建时，这个过程称为回流

特点：

- 计算元素的新位置和大小
- 触发后续的重绘
- 代价高昂，可能影响整个渲染树

#### 重绘（Repaint）

当元素样式的改变**不影响其在文档流中的位置和大小**时（如颜色、背景等），浏览器只需要重新绘制受影响的部分，这个过程称为重绘

特点：

- 不涉及布局计算
- 性能消耗小于回流
- 某些CSS属性会直接触发重绘

#### 触发条件

##### 常见的触发回流的操作：

- 页面首次渲染（无法避免）

- 浏览器窗口大小改变

- 元素尺寸或位置改变（width/height/margin/padding等）

- 内容变化（文字数量、图片大小等）

- 添加、删除可见的DOM元素

- 激活CSS伪类（如：hover）

- 计算offsetWidth/offsetHeight等布局的属性

  <img src="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetHeight/dimensions-offset.png" alt="Image:Dimensions-offset.png" style="zoom:67%;" />

  <img src="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/clientHeight/dimensions-client.png" alt="img" style="zoom:67%;" />

  ![img](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollHeight/scrollheight.png)

  scrollHeight包含padding，不包含border，margin

- 设置某些style属性

##### 常见只触发重绘的操作：

- Color/background-color改变
- visibility改变
- text-decoration改变（波浪线、上划线、下划线等）
- outline/border-radius改变（不改变布局时）

#### 浏览器渲染流程

1. 解析HTML -> 构建DOM树
2. 解析CSS -> 构建CSSOM树
3. 合并DOM和CSSOM -> 形成渲染树（Render Tree）
4. 布局（Layout/Reflow）-> 计算每个节点的位置和大小

```
DOM + CSSOM → Render Tree → Layout → Paint → Composite
```

#### 性能影响

回流比重绘的代价高得多：

- 回流可能导致整个渲染树重新计算
- 回流范围越大，性能消耗越大
- 连续的重排重绘会导致布局抖动

#### 优化策略

##### 减少回流次数

1. 集中改变样式

   ```js
   // 不好 - 触发多次回流
   el.style.width = '100px';
   el.style.height = '200px';
   
   // 好 - 使用cssText或class一次修改
   el.style.cssText = 'width:100px; height:200px;';
   // 或
   el.className = 'new-style';
   ```

2. 使用文档片段（DocumentFragment）

   **`DocumentFragment`**，文档片段接口，表示一个没有父对象的最小文档对象。

   ```js
   const fragment = document.createDocumentFragment();
   // 批量添加DOM节点到fragment
   fragment.appendChild(newNode1);
   fragment.appendChild(newNode2);
   // 最后一次性添加到DOM
   document.body.appendChild(fragment);
   ```

3. 先隐藏元素，修改完再展示

   ```js
   el.style.display = 'none';
   // 进行多项修改
   el.style.display = 'block';
   ```

4. 避免频繁读取布局属性

   ```js
   // 不好 - 强制同步布局（布局抖动）
   for(let i=0; i<100; i++) {
     el.style.width = someElements[i].offsetWidth + 'px';
   }
   
   // 好 - 先读取后修改
   const widths = someElements.map(el => el.offsetWidth);
   widths.forEach((w, i) => {
     someElements[i].style.width = w + 'px';
   });
   ```

##### 减少重绘区域

1. 使用will-change属性提示浏览器

   `will-change` 为 web 开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。

   > [!WARNING]
   >
   > **警告：** `will-change` 应该被视为最后的应对手段，用于解决现有的性能问题。不应该被用来预测性能问题。

   ```css
   .animated-element {
     will-change: transform;
   }
   ```

2. 对动画元素使用`position: absolute/fixed`脱离文档流

3. 使用css3硬件加速（transform/opacity等）

#### 现代浏览器优化

现代浏览器会：

- 批量处理回流（队列机制）
- 限制回流范围（局部回流）
- 对某些动画使用单独的合成层

但仍需开发者主动优化，特别在低端设备上

#### 开发工具监测

Chrome DevTools中：

- Performance面板可以记录回流重绘过程
- Rendering面板中的Paint flashing可高亮重绘区域



### CSS选择器

#### 类型、类和ID选择器

这个选择器组，第一个是指向了所有HTML元素`<h1>`

```css
h1 {
}
```

这个包含了一个class选择器

```css
.box {
}
```

一个id选择器

```css
#unique {
}
```

#### 标签属性选择器

根据元素上的某个标签的属性的存在以选择元素的不同方式

```css
a[title] {
}
```

根据一个有特定值的标签属性是否存在来选择：

```css
a[href="https://example.com"]
{
}
```

| 选择器              | 示例                            | 描述                                                         |
| :------------------ | :------------------------------ | :----------------------------------------------------------- |
| `[*attr*]`          | `a[title]`                      | 匹配带有一个名为*attr*的属性的元素——方括号里的值。           |
| `[*attr*=*value*]`  | `a[href="https://example.com"]` | 匹配带有一个名为*attr*的属性的元素，其值正为*value*——引号中的字符串。 |
| `[*attr*~=*value*]` | `p[class~="special"]`           | 匹配带有一个名为*attr*的属性的元素，其值正为*value*，或者匹配带有一个*attr*属性的元素，其值有一个或者更多，至少有一个和*value*匹配。注意，在一列中的好几个值，是用空格隔开的。 |
| `[*attr*|=*value*]` | `div[lang|="zh"]`               | 匹配带有一个名为*attr*的属性的元素，其值可正为*value*，或者开始为*value*，后面紧随着一个连字符。 |

#### 子字符串匹配选择器

| 选择器          | 示例                | 描述                                                         |
| :-------------- | :------------------ | :----------------------------------------------------------- |
| `[attr^=value]` | `li[class^="box-"]` | 匹配带有一个名为*attr*的属性的元素，其值开头为*value*子字符串。 |
| `[attr$=value]` | `li[class$="-box"]` | 匹配带有一个名为*attr*的属性的元素，其值结尾为*value*子字符串 |
| `[attr*=value]` | `li[class*="box"]`  | 匹配带有一个名为*attr*的属性的元素，其值的字符串中的任何地方，至少出现了一次*value*子字符串。 |

如果你想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用`i`值。这个标记告诉浏览器，要以大小写不敏感的方式匹配 ASCII 字符。没有了这个标记的话，值会按照文档语言对大小写的处理方式，进行匹配——HTML 中是大小写敏感的。

```css
li[class^="a"] {
  background-color: yellow;
}

li[class^="a" i] {
  color: red;
}
```

#### 伪类选择器

伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。

伪类就是开头为冒号的关键字。例如，`:hover` 就是一个伪类。

- :last-child 代表一组兄弟元素中的最后元素

  ```css
  li:last-child {
    border: 2px solid orange;
  }
  ```

- :first-child略

- :only-child表示没有任何兄弟元素的元素，与`:first-child:last-child`和`:nth-child(1):nth-last-child(1)`相同，但具有更小的权重性

  ```css
  li:only-child {
    color: fuchsia;
  }
  
  b:only-child {
    text-decoration: underline;
  }
  ```

- **`:nth-child()`** [伪类](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)根据元素在父元素的子元素列表中的索引来选择元素。换言之，`:nth-child()` 选择器根据父元素内的所有兄弟元素的位置来选择子元素。元素索引从 1 开始.

  - `of <selector>`语法

    通过传递一个选择器参数，我们可以选择与该选择器匹配的第 **n** 个元素。例如，下面的选择器匹配前三个设置了 `class="important"` 的列表项。

    ```css
    :nth-child(-n + 3 of li.important) {
    }
    ```

- **`:invalid`** 是 [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) [伪类选择器](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)，用来选择任何未通过[验证](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Guides/Constraint_validation)的 [`form`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/form)、[`fieldset`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/fieldset)、[`input`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/input) 或其他[表单](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference/Elements/form)元素。

  ```css
  label {
    display: block;
    margin-top: 1em;
  }
  
  input:invalid {
    background-color: ivory;
    border: none;
    outline: 2px solid red;
    border-radius: 5px;
  }
  ```

- :hover略

- :focus略

#### 伪元素

伪元素以类似方式表现。不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。

伪元素开头为双冒号 `::`。比如，`::before` 就是一个伪元素的示例。

#### 关系选择器

##### 后代选择器

用单个空格（" "）字符——组合两个选择器，比如，第二个选择器匹配的元素被选择，如果他们有一个祖先（父亲，父亲的父亲，父亲的父亲的父亲，等等）元素匹配第一个选择器。选择器利用后代组合符被称作后代选择器。

```css
.box p {
  color: red;
}
```

##### 子代关系选择器

子代关系选择器是个大于号（`>`），只会在选择器选中直接子元素的时候匹配。继承关系上更远的后代则不会匹配。例如，只选中作为`<article>`的直接子元素的`<p>`元素：

```css
ul > li {
  border-top: 5px solid red;
}
```

这里用子代关系选择器，只选中为`<ul>`的直接子元素的`<li>`元素，给了它们一个顶端边框。

如果你移去指定子代选择器的`>`的话，你最后得到的是后代选择器，所有的`<li>`会有个红色的边框。

##### 邻接兄弟

邻接兄弟选择器（`+`）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件。例如，选中紧随`<h1>`元素之后的`<p>`元素：

```css
body {
  font-family: sans-serif;
}

h1 + p {
  font-weight: bold;
  background-color: #333;
  color: #fff;
  padding: 0.5em;
}
```

##### 通用兄弟

如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（`~`）。要选中所有的`<p>`元素后*任何地方*的`<img>`元素，我们会这样做：`p ~ img`

```css
h1 ~ p {
  font-weight: bold;
  background-color: #333;
  color: #fff;
  padding: 0.5em;
}
```

#### var, const, let

- 函数提升优先于变量提升，函数提升会把整个函数的声明和赋值挪到作用域顶部，变量提升指挥把声明挪到作用域顶部
- `var`存在提升，所以能在声明之前使用。`let`, `const`因为暂时性死区，不能在声明前使用
- `var`在全局作用域下声明变量会导致变量挂载在`window`上，其他二者不会
- `let`和`const`作用基本一致，后者声明的变量不能再次赋值



#### 原型继承与Class继承

- JS中并不存在类，`class`只是语法糖，本质还是函数

  ```js
  class Person {}
  Person instanceof Function // true
  ```

##### 组合继承

```js
function Parent(value) {
	this.val = value
}
Parent.prototype.getValue = function() {
    console.log(this.val)
}

function Child(value) {
    Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

- 核心是在子类的构造函数中通过`Parent.call(this)`继承父类的属性，然后改变子类的原型为`new Parent()`来继承父类的函数

- 这种继承的优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费

##### 寄生组合继承

这种继承方式解决了组合继承在继承父类函数时调用了构造函数的缺点

```js
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  }
})

const child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```

以上继承的核心是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用父类属性问题，还能正确的找到子类的构造函数。

##### Class继承

ES6中可以通过class来实现继承，并且实现起来很简单

```js
class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}

class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}

let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```

`class`实现继承的核心在于使用`extends`表明继承自哪个父类，并且在子类构造函数中必须调用`super`，因为这段代码可以看成`Parent.call(this, value)`

JS中并不存在类，`class`的本质就是函数

#### 模块化

使用模块化的好处：

- 解决命名冲突
- 提供复用性
- 提高代码可维护性

##### 立即执行函数

早期使用立即执行函数实现模块化，通过函数作用域解决命名冲突，污染全局作用域的问题

```js
(function(globalVariable) {
  globalVeriable.test = function() {}
  // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
```

##### AMD, CMD

```js
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把require写在函数体的任何地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```

##### CommonJS

CommonJS最早在Node中使用，目前也在广泛使用，比如Webpack。目前Node中的模块管理已经和CommonJS有所区别了

```js
//a.js
module.exports = {
  a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

详细的：

```js
var module = require('./a.js')
module.a
// 这里包装了一层立即执行函数，这样就不会污染全局变量了，
// module是Node独有的一个变量
module.exports = {
  a: 1
}

// module基本实现
var module = {
  id: 'xxxx',
  exports: {} // 一个空对象
}
// exports和module.exports用法相似的原因
var exports = module.exports
var load  = function (module) {
  // 导出的东西
  var a = 1
  module.exports = a
  return module.exports
};
// 当require的时候去找到独特的id, 然后将要实用的东西用立即执行函数包装下
```

虽然 `exports` 和 `module.exports` 用法相似，但是不能对 `exports` 直接赋值。因为 `var exports = module.exports` 这句代码表明了 `exports` 和 `module.exports` 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 `exports` 赋值就会导致两者不再指向同一个内存地址，修改并不会对 `module.exports` 起效。

##### ES Module

ES Module是原生实现的模块化方案，与CommonJS有以下的区别

- CommonJS支持动态导入，`require(${path}/xx.js)`，后者目前不支持，但是已经提案

- CommonJS是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

- CommonJS在导出时都是值拷贝，就算导出的值变了，导入的值也不会变，所以如果想更新值，必须重新导入一次（导入后与原模块变量断开联系）。但是ES Module采用实时绑定的方式，导入导出的值都指向同一内存地址，所以导入值会跟随导出值变化（导入变量与原模块变量始终指向同一内存地址）

  CommonJS:

  ```js
  // a.js（CommonJS）
  let count = 1;
  function increment() {
    count++;
  }
  module.exports = { count, increment };
  
  // b.js（CommonJS）
  const { count, increment } = require('./a');
  console.log(count); // 1
  increment();
  console.log(count); // 1（值未变！）
  ```

  1. `a.js` 导出 `count` 时，**复制了一份值**（`1`）给 `b.js`。
  2. `b.js` 中的 `count` 是独立的变量，**不受原模块 `count` 变化的影响**。
  3. 即使 `a.js` 里的 `count` 被 `increment()` 修改，`b.js` 的 `count` **仍然是初始导入的值**。

  必须重新导入才能让`b.js`获取最新值

  ```js
  const a = require('./a');
  console.log(a.count); // 1
  a.increment();
  console.log(a.count); // 1（仍然不变！）
  // 必须重新加载模块（不推荐，实际开发中应避免）
  delete require.cache[require.resolve('./a')];
  const freshA = require('./a');
  console.log(freshA.count); // 2
  ```

  **缺点**：`require.cache` 操作影响性能，且不符合模块化设计初衷。

  ES Module:

  ```js
  // a.mjs（ESM）
  export let count = 1;
  export function increment() {
    count++;
  }
  
  // b.mjs（ESM）
  import { count, increment } from './a.mjs';
  console.log(count); // 1
  increment();
  console.log(count); // 2（值变了！）
  ```

  1. `a.mjs` 导出 `count` 时，`b.mjs` 导入的是**对原变量的引用**（内存地址相同）。
  2. 当 `a.mjs` 的 `count` 被 `increment()` 修改时，`b.mjs` 的 `count` **会同步更新**。
  3. 这种机制称为 **“实时绑定”（Live Binding）**。

- ES Module会编译成`require/exports`来执行

  ```js
  // 引入模块 API
  import XXX from './a.js'
  import { XXX } from './a.js'
  // 导出模块 API
  export function a() {}
  export default function() {}
  ```

#### Proxy

Proxy是ES6中新增的功能，它可以用来自定义对象中的操作。**Proxy** 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。

```js
let p = new Proxy(target, handler)
```

`target`

要使用`Proxy`包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。

`handler`

一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理`p`的行为

##### Proxy实现一个数据响应式

```js
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver)
    },
    set(target, property, value, receiver) {
      setBind(value, property)
      return Reflect.get(target, property, value)
    }
  }
  return new Proxy(obj, handler)
}

let obj = { a: 1 }
let p = onWatch(
	obj,
  (v, property) => console.log(`监听到属性${property}改变为${v}`),
  (target, property) => console.log(`'${property}' = ${target[property]}`)
)
p.a = 2 // 监听到属性a改变为2
p.a // 'a' = 2
```

在上述代码中，我们通过自定义 `set` 和 `get` 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。

#### 异步

##### 并发（concurrency）与并行（parallelism）

- 并发是宏观概念，分别有任务A和任务B，在一段时间内通过任务间的切换完成了这两个人物，这种情况称之为并发。
- 并行是微观概念，假设CPU中存在两个核心，就可以同时完成任务A、B。同时完成多个任务的情况就可以称之为并行

##### 回调函数（Callback）

回调地狱的根本问题就是：

1. 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
2. 嵌套函数一多，就很难处理错误

回调函数还存在着别的几个缺点，比如不能使用 `try catch` 捕获错误，不能直接 `return`。

> JavaScript 的 `try...catch` **只能捕获同步代码的错误**，而回调函数通常在 **异步操作（如 `setTimeout`、`fs.readFile`、`Promise.then`）完成后才执行**，此时调用栈已经退出 `try` 块，导致 `catch` 无法捕获错误。

##### Generator

常规函数只会返回一个单一值（或者不返回任何值）。

而 generator 可以按需一个接一个地返回（“yield”）多个值。它们可与 [iterable](https://zh.javascript.info/iterable) 完美配合使用，从而可以轻松地创建数据流。

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```

generator 函数与常规函数的行为不同。在此类函数被调用时，它不会运行其代码。而是返回一个被称为 “generator object” 的特殊对象，来管理执行流程。

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

// "generator function" 创建了一个 "generator object"
let generator = generateSequence();
alert(generator); // [object Generator]
```

到目前为止，上面这段代码中的 **函数体** 代码还没有开始执行

一个 generator 的主要方法就是 `next()`。当被调用时（译注：指 `next()` 方法），它会恢复上图所示的运行，执行直到最近的 `yield <value>` 语句（`value` 可以被省略，默认为 `undefined`）。然后函数执行暂停，并将产出的（yielded）值返回到外部代码。

`next()` 的结果始终是一个具有两个属性的对象：

- `value`: 产出的（yielded）的值。
- `done`: 如果 generator 函数已执行完成则为 `true`，否则为 `false`。

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

let one = generator.next();

alert(JSON.stringify(one)); // {value: 1, done: false}
```

再次调用 `generator.next()`。代码恢复执行并返回下一个 `yield` 的值

```js
let two = generator.next();

alert(JSON.stringify(two)); // {value: 2, done: false}
```

```js
let three = generator.next();

alert(JSON.stringify(three)); // {value: 3, done: true}
```

再对 `generator.next()` 进行新的调用不再有任何意义。如果我们这样做，它将返回相同的对象：`{done: true}`。

可以使用 `for..of` 循环遍历它所有的值

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1，然后是 2
}
```

当 `done: true` 时，`for..of` 循环会忽略最后一个 `value`。因此，如果我们想要通过 `for..of` 循环显示所有的结果，我们必须使用 `yield` 返回它们：

```js
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1，然后是 2，然后是 3
}
```

```js
function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
var a = foo(5);
a.next() // Object{value:6, done:false}
a.next() // Object{value:NaN, done:false}
a.next() // Object{value:NaN, done:true}
var b = foo(5);
b.next() // { value:6, done:false }
b.next(12) // { value:8, done:false }
b.next(13) // { value:42, done:true }
```

- 首先 `Generator` 函数调用和普通函数不同，它会返回一个迭代器
- 当执行第一次 `next` 时，传参会被忽略，并且函数暂停在 `yield (x + 1)` 处，所以返回 `5 + 1 = 6`
- 第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。
- 如果向next方法提供参数，返回结果就完全不一样了。第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。

**generator解决地狱回调**

```js
function *fetch() {
    yield ajax(url, () => {})
    yield ajax(url1, () => {})
    yield ajax(url2, () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

##### Promise

有三种状态，分别是：

1. 等待中（pending）
2. 完成了 （resolved）
3. 拒绝了（rejected）

一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变

```js
new Promise((resolve, reject) => {
  resolve('success')
  // 无效
  reject('reject')
})
```

构造`Promise`的时候，构造函数内部的代码是立即执行的

```js
new Promise((resolve, reject) => {
  console.log('new Promise')
  resolve('success')
})
console.log('finifsh')
// new Promise -> finifsh
```

`Promise` 实现了链式调用，也就是说每次调用 `then` 之后返回的都是一个 `Promise`，并且是一个全新的 `Promise`，原因也是因为状态不可变。如果你在 `then` 中 使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装

```js
Promise.resolve(1)
  .then(res => {
    console.log(res) // => 1
    return 2 // 包装成 Promise.resolve(2)
  })
  .then(res => {
    console.log(res) // => 2
  })
```

**Promise解决回调地狱**

```js
ajax(url)
  .then(res => {
      console.log(res)
      return ajax(url1)
  }).then(res => {
      console.log(res)
      return ajax(url2)
  }).then(res => console.log(res))
```

**Promise的缺点**

- 无法取消`Promise`
- 错误需要通过回调函数获取
- 大量微任务（如循环创建Promise）可能阻塞渲染

##### async及await

一个函数如果加上 `async` ，那么该函数就会返回一个 `Promise`

```js
async function test() {
  return "1"
}
console.log(test()) // -> Promise {<resolved>: "1"}
```

`async` 就是将函数返回值使用 `Promise.resolve()` 包裹了下，和 `then` 中处理返回值一样，并且 `await` 只能配套 `async` 使用

`async` 和 `await` 可以说是异步终极解决方案了，相比直接使用 `Promise` 来说，优势在于处理 `then` 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 `then` 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 `await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低。

```js
async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch(url)
  await fetch(url1)
  await fetch(url2)
}
```

##### 常用定时器函数

常见的定时器函数有 `setTimeout`、`setInterval`、`requestAnimationFrame`

通常来说不建议使用 `setInterval`。第一，它和 `setTimeout` 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题

```js
function demo() {
  setInterval(function(){
    console.log(2)
  },1000)
  sleep(2000)
}
demo()
```

以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。

##### 使用`requestAnimationFrame`精确实现`setInterval`

```js
function setInterval(callback, interval) {
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime
  const loop = () => {
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime >= interval) {
      startTime = endTime = now()
      callback(timer)
    }
  }
  timer = window.requestAnimationFrame(loop)
  return timer
}

let a = 0
setInterval(timer => {
  console.log(1)
  a++
  if (a === 3) cancelAnimationFrame(timer)
}, 1000)
```

首先 `requestAnimationFrame` 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题

#### 手写Promise

##### const that = this

使用 `const that = this`（或 `const self = this`）是一种常见的模式，主要用于 **解决 `this` 绑定丢失的问题**，尤其是在 **异步回调、嵌套函数、事件监听** 等场景下

JavaScript 的 `this` 是动态绑定的，它的值取决于 **函数的调用方式**。在以下情况下，`this` 会发生变化：

- 在 **嵌套函数** 或 **回调函数** 中，`this` 可能指向全局对象（如 `window`）或 `undefined`（严格模式）。
- 在 **异步操作**（如 `setTimeout`、`Promise`、事件监听）中，`this` 可能丢失原上下文。

通过 `const that = this`，可以 **保存当前上下文的 `this`**，确保在嵌套函数中仍能访问正确的对象。

1. 回调函数（如setTimeout、ajax）

   ```js
   class User {
     constructor(name) {
       this.name = name;
     }
   
     greet() {
       setTimeout(function() {
         console.log("Hello, " + this.name); // ❌ this 指向 window（或 undefined）
       }, 1000);
     }
   }
   
   const user = new User("Alice");
   user.greet(); // 输出：Hello, undefined
   ```

   修复方式：

   ```js
   greet() {
     const that = this; // 保存 this
     setTimeout(function() {
       console.log("Hello, " + that.name); // ✅ 正确：that 指向 User 实例
     }, 1000);
   }
   ```

2. 事件监听

   ```js
   class Button {
     constructor() {
       this.text = "Click me";
       document.getElementById("myButton").addEventListener("click", function() {
         console.log(this.text); // ❌ this 指向 DOM 元素（按钮）
       });
     }
   }
   ```

   修复方式

   ```js
   constructor() {
     this.text = "Click me";
     const that = this;
     document.getElementById("myButton").addEventListener("click", function() {
       console.log(that.text); // ✅ 正确：that 指向 Button 实例
     });
   }
   ```

3. 嵌套函数

   ```js
   const obj = {
     value: 42,
     getValue: function() {
       function helper() {
         return this.value; // ❌ this 指向 window（或 undefined）
       }
       return helper();
     }
   };
   console.log(obj.getValue()); // undefined
   ```

   修复方式：

   ```js
   getValue: function() {
     const that = this;
     function helper() {
       return that.value; // ✅ 正确：that 指向 obj
     }
     return helper();
   }
   ```

4. 现代解决方案

   1. 箭头函数

      箭头函数没有自己的this，会继承外层作用域的this

      ```js
      class User {
        greet() {
          setTimeout(() => {
            console.log("Hello, " + this.name); // ✅ 箭头函数继承 this
          }, 1000);
        }
      }
      ```

   2. bind方法

      ```js
      class Button {
        constructor() {
          this.text = "Click me";
          document.getElementById("myButton").addEventListener(
            "click",
            function() {
              console.log(this.text); // ✅ this 通过 bind 绑定
            }.bind(this) // 绑定当前 this
          );
        }
      }
      ```

   3. 类字段

      直接使用箭头函数定义方法（适用于React等场景）

      ```js
      class Button {
        text = "Click me";
        handleClick = () => {
          console.log(this.text); // ✅ 箭头函数绑定 this
        };
        constructor() {
          document.getElementById("myButton").addEventListener("click", this.handleClick);
        }
      }
      ```

##### 简易版Promise

```js
const PENDING = 'pending'
const RESOLVED = 'solved'
const REJECTED = 'rejected'

function MyPromise(fn) {
  const that = this
  that.state = PENDING
  that.value = null;
  that.resolvedCallbacks = []
  that.rejectedCallbacks = []
  // 待完善resolved和reject函数
  // 待完善执行fn函数
}
```

- 首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护
- 在函数体内部首先创建了常量 `that`，因为代码可能会异步执行，用于获取正确的 `this` 对象
- 一开始 `Promise` 的状态应该是 `pending`
- `value` 变量用于保存 `resolve` 或者 `reject` 中传入的值
- `resolvedCallbacks` 和 `rejectedCallbacks` 用于保存 `then` 中的回调，因为当执行完 `Promise` 时状态可能还是等待中，这时候应该把 `then` 中的回调保存起来用于状态改变时使用

继续在`MyPromise`函数体内部完善`reslove`和`reject`函数

```js
function resolve(value) {
  if (that.state === PENDING) {
    that.state = RESOLVED
    that.value = value
    that.resolvedCallbacks.map(cb => cb(that.value))
  }
}

function reject(value) {
  if (that.state === PENDING) {
    that.state = REJECTED
    that.value = value
    that.rejectedCallbacks.map(cb => cb(that.value))
  }
}
```

- 首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态
- 将当前状态更改为对应状态，并且将传入的值赋值给 `value`
- 遍历回调数组并执行

##### 实现执行Promise中传入的函数

```js
try {
  fn(resolve, reject)
} catch(e) {
  reject(e)
}
```

- 实现很简单，执行传入的参数并且将之前两个函数当做参数传进去
- 要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 `reject` 函数

##### 实现较为复杂的 `then` 函数

```js
MyPromise.prorotype.then = function(onFulfilled, onRejected) {
  const that = this
  onFulfilled = typeof onFulFilled === 'function' ? onFulfilled : v => v
  onRejected = 
    typeof onRejected === 'function'
  		? onRejected
  		: r => { throw r }
  if (that.state === PENDING) {
    that.resolvedCallbacks.push(onFulfilled)
    that.rejectedCallbacks.push(onRejected)
  }
  if (that.state === RESOLVED) {
    onFulfilled(that.value)
  }
  if (that.state === REJECTED) {
    onRejected(that.value)
  }
}
```

- 首先判断两个参数是否为函数类型，因为这两个参数是可选参数

- 当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码

  ```js
  // 该代码目前在简单版中会报错
  // 只是作为一个透传的例子
  Promise.resolve(4).then().then((value) => console.log(value))
  ```

- 接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 `push` 函数，比如如下代码就会进入等待态的逻辑

  ```js
  new MyPromise((resolve, reject) => {
    setTimeout(() => {
      resolve(1)
    }, 0)
  }).then(value => {
    console.log(value)
  })
  ```

完整代码

```js
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

class MyPromise {
  constructor(fun) {
    this.status = PENDING
    this.value = null
    this.resolvedCallbacks = []
    this.rejectedCallbacks = []

    let resolve = (value) => {
      if (this.status === PENDING) {
        this.status = RESOLVED
        this.value = value
        this.resolvedCallbacks.forEach(cb => cb(value))
      }
    }
    let reject = (reason) => {
      if (this.status === PENDING) {
        this.status = REJECTED
        this.value = reason
        this.rejectedCallbacks.forEach(cb => cb(reason))
      }
    }

    try {
      fun(resolve, reject)
    } catch(e) {
      throw e
    }
  }

  then(onResolve, onReject) {
    let fixedOnResolve = typeof onResolve === 'function' ? onResolve : v => v
    let fixedOnReject = typeof onReject === 'function' ? onReject : v => {throw v}
    if (this.status === RESOLVED) {
      fixedOnResolve(this.value)
    }
    if (this.status === REJECTED) {
      fixedOnReject(this.value)
    }
    if (this.status === PENDING) {
      this.resolvedCallbacks.push(() => fixedOnResolve(this.value))
      this.rejectedCallbacks.push(() => fixedOnResolve(this.value))
    }
  }
}
```

#### 进程与线程

##### 进程（Process）

操作系统分配资源（CPU，内存，文件等）的基本单位，可以理解为一个“正在运行的程序”

特点：

- 独立的内存空间：不同进程之间内存隔离，互不干扰
- 稳定性高：一个进程崩溃通常不会影响其他进程
- 开销大：创建、切换进程需要较多的系统资源

实例：

- 浏览器开多个标签页，每个标签页是一个独立进程
- 电脑同时运行微信、QQ、游戏，每个应用是一个进程

##### 线程（Thread）

线程是进程内的执行单元，一个进程可以包含多个线程，共享同一进程的资源

特点：

- 共享内存：同一进程的线程共享内存（高效但需注意线程安全）
- 轻量级：创建、切换线程比进程更快
- 风险点：一个线程崩溃可能导致整个进程崩溃

实例：

- 浏览器一个标签内，网络请求、渲染页面、执行JavaScript可能由不同线程处理
- 游戏运行时，一个线程负责画面渲染，另一个线程处理用户交互

| 特性              | 进程（Process）          | 线程（Thread）             |
| :---------------- | :----------------------- | :------------------------- |
| **资源分配**      | 独立内存空间             | 共享进程内存               |
| **创建/切换开销** | 大（需分配独立资源）     | 小（复用进程资源）         |
| **稳定性**        | 高（隔离性强）           | 低（线程崩溃可能影响进程） |
| **通信方式**      | 进程间通信（IPC）较复杂  | 直接读写共享内存（需同步） |
| **典型应用**      | 多任务并行（如多个应用） | 高并发任务（如服务器请求） |

#### 手写call、apply、bind

```js
call(thisArg, arg1, arg2, …, argN):
```

```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('error')
  }
  const fixedContext = context || window
  fixedContext.fn = this
  const params = [...arguments].slice(1)
  const result = fixedContext.fn(params)
  delete fixedContext.fn
  return result
}
```

```js
apply(thisArg, argsArray):
```

```js
Function.prototype.myApply = function(context, paramList) {
  if (typeof this !== 'function') {
    throw new TypeError('error')
  }
  const fixedContext = context || window
  fixedContext.fn = this
  let result
  if (paramList?.length) {
    result = fixedContext.fn(...paramList)
  } else {
    result = fixedContext.fn()
  }
  delete fixedContext.fn
  return result
}
```

```js
bind(thisArg, arg1, arg2, /* …, */ argN)
```

```js
Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('error')
  }
  const outContext = context || window
  const outParams = Array.from(arguments).slice(1)
  const originThis = this
  let newFun = function() {
    const isNew = typeof new.target !== 'undefined'
    const newParams = Array.from(arguments)
    return originThis.apply(isNew ? this : outContext, outParams.concat(newParams))
  }
  newFun.prototype = originThis.prototype
  return newFun
}
```

#### new

调用new的过程会发生四件事情

1. 新生成一个对象
2. 链接到原型
3. 绑定this
4. 返回新对象

```js
function myNew(constructor, ...args) {
  // 1. 创建一个新对象
  let obj = {}
  // 2. 把新对象的原型指向构造函数的原型
  obj.__proto__ = constructor.prototype
  // 3. 改变this指向，执行构造函数内部的代码
  let res = constructor.apply(obj, args)
  // 4. 判断函数类型执行结果
  if (res instanceof constructor) {
    return res
  }
  return obj
}
```

对于对象来说，其实都是通过 `new` 产生的，无论是 `function Foo()` 还是 `let a = { b : 1 }` 。

对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 `new Object()` 的方式创建对象需要通过作用域链一层层找到 `Object`，但是你使用字面量的方式就没这个问题。

```js
function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()
```

#### instanceof的原理

`instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `prototype`。

```js
function myInstanceof(left, right) {
  const rightProto = right.prototype
  let leftProto = left.__proto__
  while(true) {
    if (!leftProto) {
      return false
    }
    if (leftProto === rightProto) {
      return true
    }
    leftProto = leftProto.__proto__
  }
}
```

- 首先获取类型的原型
- 然后获得对象的原型
- 一直循环判断对象的原型是否等于类型的原型，知道对象原型为`null`，因为原型链最终为null

#### 为什么0.1+0.2！==0.3

因为JS采用IEEE754双精度版本（64位），并且只要采用IEEE754的语言都有该种问题

计算机是通过二进制来存储东西的，那么 `0.1` 在二进制中会表示为

```js
// (0011) 表示循环
0.1 = 2^-4 * 1.10011(0011)
```

我们可以发现，`0.1` 在二进制中是无限循环的一些数字，其实不只是 `0.1`，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。

IEEE 754 双精度版本（64位）将 64 位分为了三段

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 `0.1` 中的 `10011(0011)`

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 `0.1` 不再是 `0.1` 了，而是变成了 `0.100000000000000002`

```js
0.100000000000000002 === 0.1 // true
```

那么同样的，`0.2` 在二进制也是无限循环的，被裁剪后也失去了精度变成了 `0.200000000000000002`

```js
0.200000000000000002 === 0.2 // true
```

所以这两者相加不等于 `0.3` 而是 `0.300000000000000004`

```js
0.1 + 0.2 === 0.30000000000000004 // true
```

为什么 `console.log(0.1)` 却是正确的呢？

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证

```js
console.log(0.100000000000000002) // 0.1
```

那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

```js
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
```

#### 垃圾回收机制

V8实现了准确式GC，GC算法采用了分代式垃圾回收机制，因此V8将内存（堆）分为新生代和老生代两部分

##### 新生代算法

新生代中的对象一般存活时间比较短，使用Scavenge GC算法

在新生代空间中，内存空间分为两部分，分别为From空间和To空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入Form空间中，当From空间被占满的时候，新生代GC就会启动了。算法会检查From空间中存活的对象并复制到To空间中，如果有失活对象就销毁。当复制完成后将From空间和To空间互换，这样GC就结束了

##### 老生代算法

老生代中对象一般存活时间较长且数量也多，使用了两个算法，分别是**标记清除算法**和**标记压缩算法**

什么情况下对象会出现在老生代空间中：

- 新生代中的对象是否已经经历过一次Scavenge算法，如果经历过的话，会将对象从新生代空间移到老生代空间中
- To空间的对象占比大小超过25%，在这种情况下，为了不影响内存分配，会将对象从新生代空间移到老生代空间中

老生代中的空间很复杂，有如下几个空间

```js
enum AllocationSpace {
  // TODO(v8:7464): Actually map this space's memory as read-only.
  RO_SPACE,    // 不变的对象空间
  NEW_SPACE,   // 新生代用于 GC 复制算法的空间
  OLD_SPACE,   // 老生代常驻对象空间
  CODE_SPACE,  // 老生代代码对象空间
  MAP_SPACE,   // 老生代 map 对象
  LO_SPACE,    // 老生代大空间对象
  NEW_LO_SPACE,  // 新生代大空间对象

  FIRST_SPACE = RO_SPACE,
  LAST_SPACE = NEW_LO_SPACE,
  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,
  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE
}
```

在老生代中，以下情况会先启用标记清除算法：

- 某一个空间没有分块的时候
- 空间中被对象超过一定的限制
- 空间不能保证新生代中的对象移动到老生代中

在这个阶段中，会遍历堆中的所有对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对象内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011年，V8从stop-the-world标记切换到增量标志。在增量标记期间，GC将标记工作分解为更小的模块，可以让JS应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿的情况。但在2018年，GC技术又有了一个重大突破，这项技术名为并发标记。该技术可以让GC扫描和标记对象时，同时允许JS运行，你可以点击 [该博客](https://link.juejin.im/?target=https%3A%2F%2Fv8project.blogspot.com%2F2018%2F06%2Fconcurrent-marking.html) 详细阅读。

清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，知道所有对象都完成然后清理掉不需要的内存
